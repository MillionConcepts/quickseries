# quickseries

`quickseries` generates Python functions that perform fast vectorized power 
series approximations of mathematical functions. It can provide performance 
improvements ranging from ~3x (simple functions, no fiddling around with 
parameters) to ~100x (complicated functions, some parameter tuning).

`quickseries` is in alpha; bug reports are appreciated.

Install from source using `pip install .`. Dependencies are also described
in a Conda `environment.yml` file.

Examples and tips follow. Further documentation forthcoming.

## example of use

```
>>> import numpy as np
>>> from quickseries import quickseries

>>> bounds = (-np.pi, np.pi)
>>> approx = quickseries("sin(x)*cos(x)", point=0, order=12, bounds=bounds)
>>> x = np.linspace(*bounds, 100000)
>>> print(f"max error: {max(abs(np.sin(x) * np.cos(x) - approx(x)))}")
>>> print("original runtime:")
>>> %timeit np.sin(x) * np.cos(x)
>>> print("approx runtime:")
>>> %timeit approx(x)

max error: 0.0003270875375037813
original runtime:
968 ¬µs ¬± 2.17 ¬µs per loop (mean ¬± std. dev. of 7 runs, 1,000 loops each)
approx runtime:
325 ¬µs ¬± 3.89 ¬µs per loop (mean ¬± std. dev. of 7 runs, 1,000 loops each)
```

## limitations

* `quickseries` only works for functions ‚Ñù<sup>_n_</sup>ü°í‚Ñù for finite _n_. In
  programming terms, this means it will only produce functions that accept a 
  fixed number of floating-point or integer arguments (which may be 'arraylike'
  objects such as pandas `Series` or numpy `ndarrays`) and return a single 
  floating-point value (or a 1-D floating-point array if passed arraylike 
  arguments).
* `quickseries` only works on functions that are continuous and infinitely 
  differentiable within the domain of interest. Specifically, they must not 
  have singularities or discontinuities at `point` or within `bounds`.
* `quickseries` is not guaranteed to work for all such functions.

## tips

* `quickseries.benchmark()` offers an easy way to test the precision and
  efficiency of `quickseries.quickseries()`-generated approximations.
* Narrowing `bounds` will tend to make the approximation more accurate within
those bounds. In the example above, setting `bounds` to `(-1, 1)` provides 
~20x greater precision within the (-1, 1) interval (with the downside that 
the resulting approximation will get pretty bad past about +/-pi/2).
    * Like many optimizers, `quickseries()` tends to be much more effective 
      closer to 0 and when its input arguments have similar orders of 
      magnitude. If it is practical to shift/squeeze your data towards 0, you
      may be able to get more use out of `quickseries`. This is largely due to
      the fact that high-order polynomials are more numerically stable with 
      smaller input values.
    * Functions with a pole at 0, of course -- or whose series expansions have
      a pole at 0 -- can present an exception to this rule. It will still
      generally be better to keep their input values small.
* Increasing `order` will tend to make the approximation slower but more 
precise. In the example above, increasing `order` to 14 provides ~20x 
greater precision but makes the approximation ~20% slower.
  * This tends to have diminishing returns. In the example above, increasing 
  `order` to 30 provides no meaningful increase in precision over `order=14`, 
  but makes the approximation *slower* than `np.sin(x) * np.cos(x)`.
  * Setting `order` too high can also cause the approximation algorithm to
  fail entirely.
  * The location of precision/performance "sweet spots" in the parameter space 
  depends on the function and the approximation bounds. If you want to 
  seriously optimize a particular function in a particular interval, you will 
  need to play around with these parameters.
* The speedup (or lack thereof) that a `quickseries()`-generated approximation 
  provides can vary greatly in different operating environments and on different 
  processors.
* It can also vary depending on the length of the input arguments. It generally 
  provides most benefit on arrays with tens or hundreds of thousands of elements,
  although this again varies depending on operating environment, the particular
  approximated function, etc.
* For most functions, placing `point` in the middle of `bounds` will produce the
best results, and if you don't pass `point` at all, `quickseries` defaults to 
placing it in the middle of `bounds`.
* It is often difficult to generate a polynomial approximation that
  remains good across a wide range of input values. In some cases, it may be 
  useful to generate different functions for different parts of your code, or 
  even to perform piecewise operations with multiple functions (although this 
  of course adds complexity and overhead).
* Functions generated by `quickseries()` may in some cases be less 
space/memory-efficient even if they are more time/compute-efficient.
* By default, if you pass a simple polynomial expression to `quickseries()`
(e.g. `"x**4 + 2 * x**3"`), it does not actually generate an approximation, 
but instead simply attempts to rewrite it in a more efficient form.
    * `order`, `bounds`, and `point` are ignored in this "rewrite" mode.
    * This type of `quickseries()`-generated function should produce the same 
    results as any other Python function that straightforwardly implements a
    form of the input polynomial (down to floating-point error).
    * This can produce surprising speedups even in simple cases -- for example,
    `quickseries("x**4")` is ~20x faster than `lambda x: x ** 4` on some 
    `numpy` arrays.  
    * If you want `quickseries()` to actually create an approximation of a 
    simple polynomial, pass `approx_poly=True`.
      * When approximating a polynomial, there is generally no good reason to 
      set `order` >= that polynomial's order. If you do, the function 
      `quickseries()` generates will typically be very similar to a simple 
      rewrite of the input polynomial, but with slightly worse performance and 
      precision.
* `quickseries()` is also capable of auto-jitting the functions it generates
with `numba`. Pass the `jit=True` argument. `numba` is an optional dependency; 
install it with your preferred package manager.
  * In many, but not all, cases, this will provide a significant performance
    improvement, sometimes by an order of magnitude. It also permits calling
    `quickseries`-generated functions from within other `numba`-compiled
    functions.
  * In addition to the other inconveniences that may arise from just-in-time
  compilation, some functions that work well without `numba` may not work well
  with `numba`.
* If you pass the `precision` argument to `quickseries()`, it will attempt to
  guarantee that the function it returns will not cast input values to bit widths
  greater than the value of `precision`. Legal values of `precision` are 16, 32, 
  and 64. The returned function will not, however, attempt to reduce the precision
  of its arguments. For instance `quickseries("sin(x) + exp(x)", precision=32)`
  will return a Python `float` if passed an `float`, and a `np.float64` `ndarray`
  if passed a `np.float64` `ndarray`. However, it will return a `np.float32`
  `ndarray` if passed a `np.float32` `ndarray`, which is not guaranteed without
  the `precision=32` argument. 
  * This can lead to significant speedups and memory usage improvements in
    cases where you do not need the extra precision.
  * Note that many libraries and formats do not support the "half-float" 
    values generated by `quickseries` when passed `precision=16`. 
* `quickseries` tends to be most effective on univariate functions, mostly 
   because the number of terms in a function's power expansion increases 
   geometrically with its number of free parameters.
* By default, `quickseries` takes the analytic series expansion of the input 
  function as a strong suggestion rather than the last word on the topic, and
  performs a numerical optimization step to improve its goodness of fit across
  `bounds`. There are good reasons you might not want it to do this, though --
   for instance, if your input arguments are always going to be quite close to 
  `point`, messing with the analytic series expansion may be wasteful or even
  counterproductive. If you don't want it to do this, pass `fit_series_expansion=False`.
  In this case, `quickseries` ignores the `bounds` argument, except to infer
  a value for `point` if you do not specify one.
  * In some cases, this optimization step can become numerically unstable. In
    these cases, you may wish to experiment with constraining it rather than 
    turning it off completely. You can do this by passing `bound_series_fit=True`.
* By default, the functions that `quickseries` generates precompute all repeated
  exponents in the generated polynomial. This is a space-for-time trade, and
  may not always be desirable (or even effective). You can turn this off by 
  passing `prefactor=False`. 
  * If `jit=True`, `quickseries` does _not_ do this by default. The `numba` 
    compiler implicitly performs a similar optimization, and computing these
    terms explicitly tends to be counterproductive. If you want `quickseries`
    to do it anyway, you can pass `prefactor=True`.