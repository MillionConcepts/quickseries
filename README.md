# quickseries

`quickseries` generates Python functions that perform fast vectorized power 
series approximations of locally analytic mathematical functions. It can 
provide performance improvements ranging from ~3x (simple functions, no fiddling 
around with parameters) to ~100x (complicated functions, some parameter tuning).

`quickseries` is in alpha; bug reports are appreciated.

Install from source using `pip install .`. Dependencies are also described
in a Conda `environment.yml` file.

Examples and tips follow. Further documentation forthcoming.

## example of use

```
>>> import numpy as np
>>> from quickseries import quickseries

>>> bounds = (-np.pi, np.pi)
>>> approx = quickseries("sin(x)*cos(x)", x0=0, order=12, bounds=bounds)
>>> x = np.linspace(*bounds, 100000)
>>> print(f"max error: {max(abs(np.sin(x) * np.cos(x) - approx(x)))}")
>>> print("original runtime:")
>>> %timeit np.sin(x) * np.cos(x)
>>> print("approx runtime:")
>>> %timeit approx(x)

max error: 0.0003270875375037813
original runtime:
968 µs ± 2.17 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
approx runtime:
325 µs ± 3.89 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
```

## tips

* *NOTE: `quickseries.benchmark()` offers an easy way to test the precision and
  efficiency of `quickseries.quickseries()`-generated approximations.*
* Narrowing `bounds` will tend to make the approximation more accurate within
those bounds. In the example above, setting `bounds` to `(-1, 1)` provides 
~20x greater precision within the (-1, 1) interval (with the downside that 
the resulting approximation will get pretty bad past about +/-pi/2).
    * `quickseries()` tends to be much more effective closer to 0. You may be
      able to get more use out of it if you shift/squeeze your data towards 0.
      This is largely due to the fact that high-order polynomials are much more
      numerically stable with smaller input values.
    * Functions with a pole at 0, of course -- or whose series expansions have
      a pole at 0 -- can present an exception to this rule. It will still
      generally be better to keep their input values small.
* Increasing `order` will tend to make the approximation slower but more 
precise. In the example above, increasing `order` to 14 provides ~20x 
greater precision but makes the approximation ~20% slower.
  * This tends to have diminishing returns. In the example above, increasing 
  `order` to 30 provides no meaningful increase in precision over `order=14`, 
  but makes the approximation *slower* than `np.sin(x) * np.cos(x)`.
  * Setting `order` too high can also cause the approximation algorithm to
  fail entirely.
  * The location of precision/performance "sweet spots" in the parameter space 
  depends on the function and the approximation bounds. If you want to 
  seriously optimize a particular function in a particular interval, you will 
  need to play around with these parameters.
* The speedup (or lack thereof) that a `quickseries()`-generated approximation 
provides can vary greatly in different operating environments and on different 
processors.
* For most functions, placing `x0` in the middle of `bounds` will produce the
best results, and if you don't pass `x0` at all, `quickseries` defaults to 
placing it in the middle of `bounds`.
* Functions generated by `quickseries()` may in some cases be less 
space/memory-efficient even if they are more time/compute-efficient.
* By default, if you pass a simple polynomial expression to `quickseries()`
(e.g. `"x**4 + 2 * x**3"`), it does not actually generate an approximation, 
but instead simply attempts to rewrite it in a more efficient form.
    * `order`, `bounds`, and `x0` are ignored in this "rewrite" mode.
    * This type of `quickseries()`-generated function should produce the same 
    results as any other Python function that straightforwardly implements a
    form of the input polynomial (down to floating-point error).
    * This can produce surprising speedups even in simple cases -- for example,
    `quickseries("x**4")` is ~20x faster than `lambda x: x ** 4` on some 
    `numpy` arrays.  
    * If you want `quickseries()` to actually create an approximation of a 
    simple polynomial, pass `approx_poly=True`.
      * When approximating a polynomial, there is generally no good reason to 
      set `order` >= that polynomial's order. If you do, the function 
      `quickseries()` generates will typically be very similar to a simple 
      rewrite of the input polynomial, but with slightly worse performance and 
      precision.
* At present, `quickseries()` only works on univariate functions that are 
locally analytic within `bounds`, and generally only when such functions are
also continuous and differentiable within `bounds`. It is also not guaranteed 
to work well, or at all, on all such functions.
* `quickseries()` is also capable of auto-jitting the functions it generates
with `numba`. Pass the `jit=True` argument. `numba` is an optional dependency; 
install it with your preferred package manager.
  * In many, but not all, cases, this will provide a significant performance
    improvement, sometimes by an order of magnitude. It also permits calling
    `quickseries`-generated functions from within other `numba`-compiled
    functions.
  * In addition to the other inconveniences that may arise from just-in-time
  compilation, some functions that work well without `numba` may not work well
  with `numba`.
* If you pass the `precision` argument to `quickseries()`, it will attempt to
  guarantee that the function it returns will not cast input values to bit widths
  greater than the value of `precision`. Legal values of `precision` are 16, 32, 
  and 64. The returned function will not, however, attempt to reduce the precision
  of its arguments. For instance `quickseries("sin(x) + exp(x)", precision=32)`
  will return a Python `float` if passed an `float`, and a `np.float64` `ndarray`
  if passed a `np.float64` `ndarray`. However, it will return a `np.float32`
  `ndarray` if passed a `np.float32` `ndarray`, which is not guaranteed without
  the `precision=32` argument. 
  * This can lead to significant speedups and memory usage improvements in
    cases where you do not need the extra precision.
  * Note that many libraries and formats do not support the "half-float" 
    values generated by `quickseries` when passed `precision=16`. 
